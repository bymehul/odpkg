package main

import "core:os"
import "core:strings"

read_lock :: proc(path: string) -> ([dynamic]Resolved_Dep, bool) {
    if !os.exists(path) {
        return nil, false
    }

    data, ok := os.read_entire_file(path)
    if !ok do return nil, false
    defer delete(data)

    lines, err := strings.split_lines(string(data))
    if err != nil {
        return nil, false
    }
    defer delete(lines)

    deps := make([dynamic]Resolved_Dep)
    current := Resolved_Dep{}
    has_block := false

    for line in lines {
        trimmed := strings.trim_space(line)
        if trimmed == "" do continue
        if strings.has_prefix(trimmed, "#") do continue

        if strings.has_prefix(trimmed, "[[") && strings.has_suffix(trimmed, "]]" ) {
            flush_current(&deps, &current, &has_block)
            section := trimmed[2:len(trimmed)-2]
            if section == "dependency" {
                has_block = true
            } else {
                has_block = false
            }
            continue
        }

        if !has_block do continue

        eq := strings.index_byte(trimmed, '=')
        if eq < 0 do continue
        key := strings.trim_space(trimmed[:eq])
        value := strings.trim_space(trimmed[eq+1:])
        value = trim_quotes(value)

        switch key {
        case "name":
            if current.dep.name != "" do delete(current.dep.name)
            current.dep.name = strings.clone(value)
        case "repo":
            if current.dep.repo != "" do delete(current.dep.repo)
            repo, ok_repo := normalize_repo(value)
            if ok_repo {
                current.dep.repo = strings.clone(repo)
            }
        case "ref":
            if current.dep.ref != "" do delete(current.dep.ref)
            current.dep.ref = strings.clone(value)
        case "commit":
            if current.commit != "" do delete(current.commit)
            current.commit = strings.clone(value)
        case "hash":
            if current.hash != "" do delete(current.hash)
            current.hash = strings.clone(value)
        }
    }

    flush_current(&deps, &current, &has_block)
    return deps, true
}

write_lock :: proc(path: string, deps: []Resolved_Dep) -> bool {
    sb := strings.builder_make()
    defer strings.builder_destroy(&sb)

    strings.write_string(&sb, "# This file is generated by odpkg\n")
    for d in deps {
        strings.write_string(&sb, "\n[[dependency]]\n")

        line := strings.concatenate({"name = \"", d.dep.name, "\"\n"})
        strings.write_string(&sb, line)
        delete(line)

        line = strings.concatenate({"repo = \"github.com/", d.dep.repo, "\"\n"})
        strings.write_string(&sb, line)
        delete(line)

        line = strings.concatenate({"ref = \"", d.dep.ref, "\"\n"})
        strings.write_string(&sb, line)
        delete(line)

        line = strings.concatenate({"commit = \"", d.commit, "\"\n"})
        strings.write_string(&sb, line)
        delete(line)

        if d.hash != "" {
            line = strings.concatenate({"hash = \"", d.hash, "\"\n"})
            strings.write_string(&sb, line)
            delete(line)
        }
    }

    content := strings.to_string(sb)
    ok := os.write_entire_file(path, transmute([]u8)content)
    return ok
}

flush_current :: proc(deps: ^[dynamic]Resolved_Dep, current: ^Resolved_Dep, has_block: ^bool) {
    if !has_block^ do return
    if current.dep.name == "" || current.dep.repo == "" || current.commit == "" {
        clear_resolved(current)
        has_block^ = false
        return
    }
    append(deps, current^)
    current^ = Resolved_Dep{}
    has_block^ = false
}

clear_resolved :: proc(item: ^Resolved_Dep) {
    if item == nil do return
    if item.dep.name != "" do delete(item.dep.name)
    if item.dep.repo != "" do delete(item.dep.repo)
    if item.dep.ref != "" do delete(item.dep.ref)
    if item.commit != "" do delete(item.commit)
    if item.hash != "" do delete(item.hash)
}

normalize_repo :: proc(value: string) -> (string, bool) {
    repo, _, ok := parse_repo_spec(value)
    if ok do return repo, true
    return "", false
}
